#include "define.h"
#include "serial.h"
#include "lib.h"



/***************************************************
* memset -- メモリ書き換え
*
* パラメータ
*    b -- 書き換え用のバッファ
*    c -- 書き換える内容
*    len -- 書き換えるバイト数
*
* 戻り値
*    b -- 書き換え後のバッファ
*
***************************************************/
void *memset( void *b, int c, long len )
{
    char *p;

    for ( p = b; len > 0; len-- )
    {
        *(p++) = c;
    }
    return b;
}


/***************************************************
* memcpy -- メモリコピー
*
* パラメータ
*    dst -- コピー先のバッファ
*    src -- コピー元のバッファ
*    len -- 書き換えるバイト数
*
* 戻り値
*    dst -- コピー後のバッファ
*
***************************************************/
void *memcpy( void *dst, const void *src, long len )
{
    char *d = dst;
    const char *s = src;

    for ( ; len > 0; len-- )
    {
        *(d++) = *(s++);
    }
    return dst;
}


/***************************************************
* memcmp -- メモリ比較
*
* パラメータ
*    b1 -- 比較用のバッファ1
*    b2 -- 比較用のバッファ2
*   len -- 比較するバイト数
*
* 戻り値
*    0 -- 処理終了
*   -1 -- エラー：バッファ1が不足
*    1 -- エラー：バッファ2が不足
*
***************************************************/
int memcmp( const void *b1, const void *b2, long len )
{
    const char *p1 = b1;
    const char *p2 = b2;

    for ( ; len > 0; len-- )
    {
        if ( *p1 != *p2 )
        {
            return (*p1 > *p2) ? 1 : -1;
        }
        p1++;
        p2++;
    }
    return 0;
}


/***************************************************
* strlen -- 文字列長取得
*
* パラメータ
*    s -- 比較用のバッファ1
*
* 戻り値
*    len -- 文字列長
*
***************************************************/
int strlen( const char *s )
{
    int len;
    for ( len = 0; *s; s++, len++ )
    {
        ;
    }
    return len;
}


/***************************************************
* strcpy -- 文字列長取得
*
* パラメータ
*    *dst -- コピー先の文字列バッファ
*    *src -- コピー元の文字列バッファ
*
* 戻り値
*    d -- コピー後の文字列
*
***************************************************/
char *strcpy( char *dst, const char *src )
{
    char *d = dst;
    
    for ( ;; dst++, src++ )
    {
        *dst = *src;
        if (!*src)
        {
            break;
        }
    }
    return d;
}


/***************************************************
* strcmp -- 文字列比較
*
* パラメータ
*    *s1 -- 比較文字列1
*    *s2 -- 比較文字列2
*
* 戻り値
*    0 -- 正常終了
*    1 -- 比較文字列1の異常
*   -1 -- 比較文字列2が異常
*
***************************************************/
int strcmp( const char *s1, const char *s2 )
{
    while ( *s1 || *s2 )
    {
        if ( *s1 != *s2 )
        {
            return (*s1 > *s2) ? 1 : -1;
        }
        s1++;
        s2++;
    }
    return 0;
}


/***************************************************
* strncmp -- 文字列比較
*
* パラメータ
*    *s1 -- 比較文字列1
*    *s2 -- 比較文字列2
*
* 戻り値
*    0 -- 正常終了
*    1 -- 比較文字列1の異常
*   -1 -- 比較文字列2が異常
*
***************************************************/
int strncmp( const char *s1, const char *s2, int len )
{
    while ( (*s1 || *s2) && (len > 0) )
    {
        if ( *s1 != *s2 )
        {
            return (*s1 > *s2) ? 1 : -1;
        }
        s1++;
        s2++;
        len--;
    }
    return 0;
}


/***************************************************
* putc -- 1文字送信
*
* パラメータ
*    c -- 送信する文字
*
* 戻り値
*    0 -- 
*
***************************************************/
int putc( unsigned char c )
{
    if ( c == '\n' )
    {
        serial_send_byte( SERIAL_DEFAULT_DEVICE, '\r' );
    }
    return serial_send_byte( SERIAL_DEFAULT_DEVICE, c );
}


/***************************************************
* puts -- 文字列送信
*
* パラメータ
*    s -- 送信する文字列
*
* 戻り値
*    0 -- 処理終了
*   -1 -- エラー
*
***************************************************/
int puts( unsigned char *str )
{
    if ( NULL == str )
    {
        return -1;
    }

    while ( *str )
    {
        putc( *(str++) );
    }
    return 0;
}


/***************************************************
* putxval -- 数値出力
*
* パラメータ
*    value  -- 表示する値
*    column -- 表示桁数
*
* 戻り値
*    0 -- 処理終了
*
***************************************************/
int putxval( unsigned long value, int column )
{
    char buf[9];    // 文字列出力用バッファ
    char *p;
    
    
    // 下の桁から処理するので、バッファの終端から利用する
    p = buf + sizeof(buf) - 1;
    *(p--) = '\0';
    
    if ( !value && !column )
    {
        column++;
    }
    
    while ( value || column )
    {
        // 16進文字に変換してバッファに格納する
        *(p--) = "0123456789abcdef"[value & 0xf];
        // 次の桁に進める
        value >>= 4;
        
        if ( column )
        {
            column--;
        }
    }
    
    puts(p + 1);
    
    return 0;
}
